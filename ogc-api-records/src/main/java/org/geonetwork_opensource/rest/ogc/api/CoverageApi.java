/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech) (5.0.0-beta).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
package org.geonetwork_opensource.rest.ogc.api;

import org.geonetwork_opensource.rest.ogc.model.Exception;
import io.swagger.annotations.*;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.CookieValue;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RequestPart;
import org.springframework.web.context.request.NativeWebRequest;
import org.springframework.web.multipart.MultipartFile;

import java.util.List;
import java.util.Map;
import java.util.Optional;
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.SpringCodegen", date = "2020-07-01T11:33:57.311+02:00[Europe/Paris]")
@Api(value = "Coverage", description = "the Coverage API")
public interface CoverageApi {

    default Optional<NativeWebRequest> getRequest() {
        return Optional.empty();
    }

    /**
     * GET /collections/{collectionId}/coverages/all : retrieve a coverages rangeset; use content negotiation to request HTML or GeoJSON
     *
     * @param collectionId Identifier (name) of a specific collection (required)
     * @param subset get a subset of the coverage by slicing or trimming among one axis (optional)
     * @param rangeSubset subset the resulting coverage by choosing and/or rearrange particular fields (optional)
     * @param scaleFactor scale the resulting coverage either among all axes by a given factor (optional)
     * @param scaleAxis scale the resulting coverage either among one axis by a given factor (optional)
     * @param scaleSize scale the resulting coverage either among one axis to a given size (optional)
     * @param scaleExtent scale the resulting coverage either among one axis to a given extent (optional)
     * @param subsettingcrs specify the projection in which the subsets are expressed (optional)
     * @param outputcrs reproject the output coverage to the given (optional)
     * @param interpolation specify the interpolation method used during reprojection and scaling (optional)
     * @return A full coverage. (status code 200)
     *         or An error occured. (status code 200)
     */
    @ApiOperation(value = "retrieve a coverages rangeset; use content negotiation to request HTML or GeoJSON", nickname = "getCoverageAll", notes = "", response = String.class, tags={ "Coverage", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "A full coverage.", response = String.class),
        @ApiResponse(code = 200, message = "An error occured.", response = Exception.class) })
    @RequestMapping(value = "/collections/{collectionId}/coverages/all",
        produces = { "application/multipart+related", "image/_*", "application/_*", "text/html", "application/json",  }, 
        method = RequestMethod.GET)
    default ResponseEntity<String> getCoverageAll(@ApiParam(value = "Identifier (name) of a specific collection",required=true) @PathVariable("collectionId") String collectionId,@ApiParam(value = "get a subset of the coverage by slicing or trimming among one axis")  @RequestParam(value = "subset", required = false) String subset,@ApiParam(value = "subset the resulting coverage by choosing and/or rearrange particular fields")  @RequestParam(value = "rangeSubset", required = false) String rangeSubset,@ApiParam(value = "scale the resulting coverage either among all axes by a given factor")  @RequestParam(value = "scaleFactor", required = false) String scaleFactor,@ApiParam(value = "scale the resulting coverage either among one axis by a given factor")  @RequestParam(value = "scaleAxis", required = false) String scaleAxis,@ApiParam(value = "scale the resulting coverage either among one axis to a given size")  @RequestParam(value = "scaleSize", required = false) String scaleSize,@ApiParam(value = "scale the resulting coverage either among one axis to a given extent")  @RequestParam(value = "scaleExtent", required = false) String scaleExtent,@ApiParam(value = "specify the projection in which the subsets are expressed")  @RequestParam(value = "subsettingcrs", required = false) String subsettingcrs,@ApiParam(value = "reproject the output coverage to the given")  @RequestParam(value = "outputcrs", required = false) String outputcrs,@ApiParam(value = "specify the interpolation method used during reprojection and scaling")  @RequestParam(value = "interpolation", required = false) String interpolation) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * GET /collections/{collectionId}/coverage/description : returns the whole coverage description consisting of domainset, rangetype, and metadata (but not the rangeset)
     *
     * @param collectionId Identifier (name) of a specific collection (required)
     * @param subset get a subset of the coverage by slicing or trimming among one axis (optional)
     * @return A coverage description. (status code 200)
     *         or An error occured. (status code 200)
     */
    @ApiOperation(value = "returns the whole coverage description consisting of domainset, rangetype, and metadata (but not the rangeset)", nickname = "getCoverageDescription", notes = "", response = String.class, tags={ "Coverage", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "A coverage description.", response = String.class),
        @ApiResponse(code = 200, message = "An error occured.", response = Exception.class) })
    @RequestMapping(value = "/collections/{collectionId}/coverage/description",
        produces = { "application/json", "text/html" }, 
        method = RequestMethod.GET)
    default ResponseEntity<String> getCoverageDescription(@ApiParam(value = "Identifier (name) of a specific collection",required=true) @PathVariable("collectionId") String collectionId,@ApiParam(value = "get a subset of the coverage by slicing or trimming among one axis")  @RequestParam(value = "subset", required = false) String subset) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * GET /collections/{collectionId}/coverage/domainset : retrieve a coverages domainset; use content negotiation to request HTML or GeoJSON
     *
     * @param collectionId Identifier (name) of a specific collection (required)
     * @param subset get a subset of the coverage by slicing or trimming among one axis (optional)
     * @return A coverages domainset. (status code 200)
     *         or An error occured. (status code 200)
     */
    @ApiOperation(value = "retrieve a coverages domainset; use content negotiation to request HTML or GeoJSON", nickname = "getCoverageDomainSet", notes = "", response = Object.class, tags={ "Coverage", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "A coverages domainset.", response = Object.class),
        @ApiResponse(code = 200, message = "An error occured.", response = Exception.class) })
    @RequestMapping(value = "/collections/{collectionId}/coverage/domainset",
        produces = { "application/json", "text/html" }, 
        method = RequestMethod.GET)
    default ResponseEntity<Object> getCoverageDomainSet(@ApiParam(value = "Identifier (name) of a specific collection",required=true) @PathVariable("collectionId") String collectionId,@ApiParam(value = "get a subset of the coverage by slicing or trimming among one axis")  @RequestParam(value = "subset", required = false) String subset) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf(""))) {
                    String exampleString = "";
                    ApiUtil.setExampleResponse(request, "", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * GET /collections/{collectionId}/coverage/metadata : retrieve a coverage&#39;s metadata; use content negotiation to request HTML or GeoJSON
     *
     * @param collectionId Identifier (name) of a specific collection (required)
     * @return A coverage&#39;s metadata. (status code 200)
     *         or An error occured. (status code 200)
     */
    @ApiOperation(value = "retrieve a coverage's metadata; use content negotiation to request HTML or GeoJSON", nickname = "getCoverageMetadata", notes = "", response = String.class, tags={ "Coverage", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "A coverage's metadata.", response = String.class),
        @ApiResponse(code = 200, message = "An error occured.", response = Exception.class) })
    @RequestMapping(value = "/collections/{collectionId}/coverage/metadata",
        produces = { "application/json", "text/html" }, 
        method = RequestMethod.GET)
    default ResponseEntity<String> getCoverageMetadata(@ApiParam(value = "Identifier (name) of a specific collection",required=true) @PathVariable("collectionId") String collectionId) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * GET /collections/{collectionId}/coverage : description of the coverage offering identified by {collectionId} including envelope
     * Coverage offering identified by {collectionId}. Use content negotiation to request HTML or GeoJSON.
     *
     * @param collectionId Identifier (name) of a specific collection (required)
     * @return Information about the coverage collection. (status code 200)
     *         or An error occured. (status code 200)
     */
    @ApiOperation(value = "description of the coverage offering identified by {collectionId} including envelope", nickname = "getCoverageOffering", notes = "Coverage offering identified by {collectionId}. Use content negotiation to request HTML or GeoJSON.", response = String.class, tags={ "Coverage", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "Information about the coverage collection.", response = String.class),
        @ApiResponse(code = 200, message = "An error occured.", response = Exception.class) })
    @RequestMapping(value = "/collections/{collectionId}/coverage",
        produces = { "application/json", "text/html" }, 
        method = RequestMethod.GET)
    default ResponseEntity<String> getCoverageOffering(@ApiParam(value = "Identifier (name) of a specific collection",required=true) @PathVariable("collectionId") String collectionId) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * GET /collections/{collectionId}/coverages/rangeset : retrieve a coverage&#39;s rangeset; use content negotiation to request HTML or GeoJSON
     *
     * @param collectionId Identifier (name) of a specific collection (required)
     * @param subset get a subset of the coverage by slicing or trimming among one axis (optional)
     * @return A coverage&#39;s range set. (status code 200)
     *         or An error occured. (status code 200)
     */
    @ApiOperation(value = "retrieve a coverage's rangeset; use content negotiation to request HTML or GeoJSON", nickname = "getCoverageRangeSet", notes = "", response = String.class, tags={ "Coverage", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "A coverage's range set.", response = String.class),
        @ApiResponse(code = 200, message = "An error occured.", response = Exception.class) })
    @RequestMapping(value = "/collections/{collectionId}/coverages/rangeset",
        produces = { "image/_*", "application/_*", "text/html", "application/json",  }, 
        method = RequestMethod.GET)
    default ResponseEntity<String> getCoverageRangeSet(@ApiParam(value = "Identifier (name) of a specific collection",required=true) @PathVariable("collectionId") String collectionId,@ApiParam(value = "get a subset of the coverage by slicing or trimming among one axis")  @RequestParam(value = "subset", required = false) String subset) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * GET /collections/{collectionId}/coverage/rangetype : retrieve a coverage&#39;s rangetype; use content negotiation to request HTML or GeoJSON
     *
     * @param collectionId Identifier (name) of a specific collection (required)
     * @return A coverage&#39;s rangetype. (status code 200)
     *         or An error occured. (status code 200)
     */
    @ApiOperation(value = "retrieve a coverage's rangetype; use content negotiation to request HTML or GeoJSON", nickname = "getCoverageRangeType", notes = "", response = Object.class, tags={ "Coverage", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "A coverage's rangetype.", response = Object.class),
        @ApiResponse(code = 200, message = "An error occured.", response = Exception.class) })
    @RequestMapping(value = "/collections/{collectionId}/coverage/rangetype",
        produces = { "application/geo+json", "text/html", "application/json",  }, 
        method = RequestMethod.GET)
    default ResponseEntity<Object> getCoverageRangeType(@ApiParam(value = "Identifier (name) of a specific collection",required=true) @PathVariable("collectionId") String collectionId) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf(""))) {
                    String exampleString = "";
                    ApiUtil.setExampleResponse(request, "", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }

}
